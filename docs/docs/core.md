# `core.py` Module Documentation

## Module Overview

The `core.py` module defines the `MeowdocCore` class, which is the central component for generating documentation for Python projects using Large Language Models (LLMs) and the MkDocs documentation generator. It handles the processing of Python files, leveraging an LLM to generate Markdown documentation, and creating necessary files for MkDocs.  The core logic includes identifying Python files, reading their content, generating documentation using an LLM, and writing the generated Markdown to the appropriate directories.

## `MeowdocCore` Class

This class orchestrates the documentation generation process.

### Initialization (`__init__`)

```python
def __init__(
    self, 
    input_path,
    mkdocs_dir,
    docs_dir,
    ignore_patterns,
    project_name,
    project_description,
    repo_url,
    llm_provider,
):
```

Initializes a `MeowdocCore` object.

**Parameters:**

*   `input_path` (str): The path to the directory or file containing the Python code to document.
*   `mkdocs_dir` (str): The path to the MkDocs project directory. This is where the `mkdocs.yml` configuration file resides.
*   `docs_dir` (str): The path to the `docs` directory within the MkDocs project, where the generated Markdown files will be placed.
*   `ignore_patterns` (list): A list of filename patterns to ignore during the documentation generation process (e.g., `['*.pyc', 'test*.py']`). These patterns use `fnmatch` syntax.
*   `project_name` (str): The name of the project for which documentation is being generated.  Used in the `index.md` creation.
*   `project_description` (str): A brief description of the project, used in the `index.md` creation.
*   `repo_url` (str): The URL of the project's repository (e.g., GitHub).  (Currently unused in provided code, but intended to be included in index.md creation.)
*   `llm_provider`: An object that provides an interface to an LLM. This object should have a `generate` method that takes a prompt as input and returns the LLM's response.

**Example:**

```python
from llm_interface import LLMInterface # Hypothetical LLM Interface
llm = LLMInterface()
core = MeowdocCore(
    input_path="./my_project",
    mkdocs_dir="./mkdocs_project",
    docs_dir="docs",
    ignore_patterns=["__init__.py"],
    project_name="My Project",
    project_description="A simple project.",
    repo_url="https://github.com/example/my_project",
    llm_provider=llm
)
```

**Logging:**

The constructor also configures basic logging to provide informative messages during the documentation generation process.

### `generate_docs` Method

```python
def generate_docs(self, file_path, all_file_contents):
```

Generates Markdown documentation for a single Python file using an LLM, taking into account the contents of other related files for context.

**Parameters:**

*   `file_path` (str): The absolute path to the Python file to document.
*   `all_file_contents` (dict): A dictionary where keys are relative file paths (relative to the `input_path`) and values are the corresponding file contents (strings). This provides context from other files in the project.

**Returns:**

*   str: The generated Markdown documentation, or `None` if an error occurred.

**Functionality:**

1.  **File Content Retrieval:**  Retrieves the content of the target file from the `all_file_contents` dictionary using the relative path.
2.  **Prompt Construction:** Constructs a detailed prompt to guide the LLM. This prompt includes:
    *   The content of the target Python file.
    *   The content of other relevant files in the project (from `all_file_contents`) to provide context.
    *   Specific instructions on the desired format and content of the generated documentation, including:
        *   Module-level description.
        *   Descriptions of functions and classes (parameters, return values, docstrings).
        *   Interaction with other modules.
        *   Example usage.
        *   Clear headings and subheadings.
        *   Inference of purpose from code structure when docstrings are missing.
3.  **LLM Interaction:** Sends the prompt to the LLM via the `llm_provider` and retrieves the generated documentation. Handles potential exceptions during LLM calls, logging errors.
4.  **Markdown Output:** Returns the Markdown documentation generated by the LLM.

**Example:**

```python
# Assuming core is an instance of MeowdocCore and file_contents is populated.
file_path = "./my_project/module1.py"
docs = core.generate_docs(file_path, file_contents)
if docs:
    print(docs)
```

### `create_index` Method

```python
def create_index(self, mkdocs_dir, docs_dir, readme_content):
```

Creates an `index.md` file in the `docs` directory of the MkDocs project. This serves as the main landing page for the documentation.

**Parameters:**

*   `mkdocs_dir` (str): The path to the MkDocs project directory.
*   `docs_dir` (str): The path to the `docs` directory within the MkDocs project.
*   `readme_content` (str): The content to write into the `index.md` file.  This might come from a README.md file in the source project.

**Functionality:**

Writes the given `readme_content` to the `index.md` file, effectively creating or overwriting the main documentation page.

**Example:**

```python
# Assuming core is an instance of MeowdocCore.
core.create_index("./mkdocs_project", "docs", "# My Project\nWelcome to my project's documentation!")
```

### `should_ignore` Method

```python
def should_ignore(self, path, ignore_patterns):
```

Determines whether a given file or directory path should be ignored based on a list of filename patterns.

**Parameters:**

*   `path` (str): The path to check.
*   `ignore_patterns` (list): A list of filename patterns to ignore (e.g., `['*.pyc', 'test*.py']`). Patterns use `fnmatch` syntax.

**Returns:**

*   bool: `True` if the path or any of its parent directories should be ignored, `False` otherwise.

**Functionality:**

1.  **Absolute Path Conversion:** Converts the input `path` to an absolute path for consistent comparisons.
2.  **Iterative Parent Directory Check:** Iteratively checks the basename of the path and all its parent directories against the provided `ignore_patterns`.  It traverses up the directory tree.
3.  **Pattern Matching:** Uses `fnmatch.fnmatch` to determine if the basename of the path or any parent directory matches any of the ignore patterns.
4.  **Ignores MkDocs Directory:**  Will ignore the `mkdocs.yml` directory.

**Example:**

```python
# Assuming core is an instance of MeowdocCore.
ignore_patterns = ['*.pyc', 'test*.py']
should_ignore = core.should_ignore("./my_project/module1.pyc", ignore_patterns)
print(should_ignore)  # Output: True if module1.pyc matches the pattern.

should_ignore = core.should_ignore("./my_project/module1.py", ignore_patterns)
print(should_ignore) # Output: False

should_ignore = core.should_ignore("./mkdocs_project", ignore_patterns)
print(should_ignore) # Output: False (because mkdocs_dir is handled differently elsewhere)
```

### `process_path` Method

```python
def process_path(self, input_path=None):
```

Processes a given file or directory, generating documentation for Python files and creating corresponding Markdown files.

**Parameters:**

*   `input_path` (str, optional): The path to the directory or file to process. If `None`, uses the `input_path` from the object's initialization.

**Returns:**

*   list: A list of paths to the generated Markdown files.

**Functionality:**

1.  **Path Handling:**  Handles both file and directory inputs. Uses the object's `input_path` if none is provided to the function call.
2.  **Ignore Check:** Checks if the `input_path` should be ignored using the `should_ignore` method.  Also ignores the `mkdocs_dir` directory.
3.  **File Processing:** If the input is a file:
    *   Reads the file's content.
    *   Calls `generate_docs` to generate documentation.
    *   Writes the generated Markdown to a file in the `docs_dir` with a `.md` extension.
4.  **Directory Processing:** If the input is a directory:
    *   Recursively walks through the directory tree.
    *   For each file:
        *   Checks if the file should be ignored.
        *   Reads the file's content.
        *   Calls `generate_docs` to generate documentation.
        *   Writes the generated Markdown to a file in the `docs_dir`, preserving the directory structure.
5.  **Error Handling:** Includes error handling for file reading and documentation generation.
6.  **File Contents Context:** `all_file_contents` is initialized *outside* of the loop, ensuring all file contents are available to the `generate_docs` function for each file. The keys of `all_file_contents` are *relative paths*.
7.  **Return Value:** Returns a list of the paths to all generated Markdown files.

**Example:**

```python
# Assuming core is an instance of MeowdocCore.
generated_files = core.process_path("./my_project")
print(generated_files) # prints a list of generated markdown file paths
```

### `create_project_index` Method

```python
def create_project_index(
    self,
):
```

Generates the project's main `index.md` file within the `docs` directory.  This includes the project name, description, installation instructions, contributing guidelines (AI-generated), and license/repository information.

**Parameters:**

*   None

**Returns:**

*   None

**Functionality:**

1.  **Configuration Retrieval:** Retrieves configuration parameters from the object (mkdocs_dir, docs_dir, project_name, project_description).
2.  **AI-Generated Contributing Section:** Uses the LLM to generate a 'Contributing' section in Markdown format, tailoring the prompt with the project name.
3.  **Index Content Creation:** Creates a string containing the `index.md` file's content, including the project name, description, installation instructions (using the project name), the AI-generated 'Contributing' section, and static "License" and "Repository" sections.
4.  **File Writing:** Writes the generated content to `index.md` within the specified `docs_dir` inside the `mkdocs_dir`.

**Example:**

```python
# Assuming core is an instance of MeowdocCore.
core.create_project_index() # creates the index.md file using project info and AI generated description.
```

## Module-Level Interactions

The `core.py` module primarily interacts with the following:

*   **`os`:** For file system operations (walking directories, creating directories, reading files).
*   **`logging`:** For logging information, warnings, and errors during the documentation generation process.
*   **`fnmatch`:** For matching filenames against ignore patterns.
*   **`pathlib`:** For creating directories if they don't exist.
*   **`llm_provider`:** An external object implementing an LLM interface used to generate documentation from prompts. It is injected into `MeowdocCore` during instantiation. This assumes the existence of a suitable LLM interface, potentially in a separate module (e.g., `llm_interface.py` as exemplified earlier.)

## Usage Examples

**Complete example workflow:**

```python
import os
import logging
import fnmatch
import pathlib

class MockLLM:
    def generate(self, prompt):
        return "Mock documentation generated from prompt:\n" + prompt

class MeowdocCore:
    """A class to generate documentation for Python files using LLM and MkDocs."""

    def __init__(
        self, 
        input_path,
        mkdocs_dir,
        docs_dir,
        ignore_patterns,
        project_name,
        project_description,
        repo_url,
        llm_provider,
#         model="gemini-2.0-flash-exp",
    ):
        """Initialize the DocumentationGenerator with a specified AI model."""
        self.input_path=input_path
        self.mkdocs_dir=mkdocs_dir
        self.docs_dir=docs_dir
        self.ignore_patterns=ignore_patterns
        self.project_name=project_name
        self.project_description=project_description
        self.repo_url=repo_url
        self.llm_provider = llm_provider
#        self.model = model
        logging.basicConfig(
            level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
        )

    def generate_docs(self, file_path, all_file_contents):
        """Generates documentation for a single file with context from all related files."""
        filename = os.path.basename(file_path)
        relative_filename = os.path.relpath(file_path, self.input_path) # Get the relative path
        filename = relative_filename

        try:
            code = all_file_contents[filename]
        except KeyError:
            logging.error(f"File content not found for {file_path}")
            return None
        finally:
            logging.info(f"File content found for {file_path}")

        prompt = "Generate comprehensive documentation in Markdown format for the following Python file (do not give the Markdown in backticks.), considering the context of related files:\n\n"
        prompt += f"File: {filename}\n```python\n{code}\n```\n\n"

        prompt += "Context from related files:\n\n"
        for other_filename, other_code in all_file_contents.items():
            if other_filename != filename:
                prompt += f"File: {other_filename}\n```python\n{other_code}\n```\n\n"

        prompt += """
        Include:
        *   A concise Module-level description.
        *   Descriptions of functions and classes, including parameters, return values, and docstrings.
        *   Clearly indicate how this file interacts with other modules (using examples).
        *   Provide example usage.
        *   Descriptions of each function and class, including parameters, return values, and docstrings.
        *   Use clear headings and subheadings (e.g., ##, ###).
        *   Provide example usage where possible.
        *   If there are no docstrings, try to infer the purpose of the code based on its structure and variable names.
        """

        try:
            # response = genai.GenerativeModel(model_name=self.model).generate_content(
            #     prompt
            # )
            response = self.llm_provider.generate(prompt)
            print(f"generated content for `{filename}`")
            return response
        except Exception as e:
            logging.exception(f"Error calling LLM: {e}")
            return None

    def create_index(self, mkdocs_dir, docs_dir, readme_content):
        """Creates the index.md file with the provided content."""
        index_path = os.path.join(mkdocs_dir, docs_dir, "index.md")
        with open(index_path, "w", encoding="utf-8") as outfile:
            outfile.write(readme_content)
        print(f"README written to: {index_path}")

    def should_ignore(self, path, ignore_patterns):
        """Checks if a path or any of its parent directories should be ignored."""
        path = os.path.abspath(
            path
        )  # Convert to absolute path for consistent comparison
        while path:
            base_name = os.path.basename(path)
            for pattern in ignore_patterns:
                if fnmatch.fnmatch(base_name, pattern):
                    # logging.info(
                    #     f"Ignoring {path} because it matches pattern: {pattern}"
                    # )
                    return True
            path = os.path.dirname(path)  # Move up to the parent directory
            if path == os.path.dirname(path):  # Check for root
                break
        return False

    def process_path(self, input_path=None):
        if input_path is None:
            input_path = self.input_path

        mkdocs_dir = self.mkdocs_dir
        docs_dir_name = self.docs_dir
        ignore_patterns = self.ignore_patterns
        logging.info(f"Processing path: {input_path}")
        generated_files = []

        if ignore_patterns is None:
            ignore_patterns = []

        if self.should_ignore(input_path, ignore_patterns):
            logging.info(f"Ignoring path (matches pattern): {input_path}")
            return []

        if os.path.abspath(input_path) == os.path.abspath(mkdocs_dir):
            logging.info(f"Ignoring the mkdocs directory: {input_path}")
            return []

        docs_dir = os.path.join(mkdocs_dir, docs_dir_name)

        if os.path.isfile(input_path):
            logging.info(f"Input is a file: {input_path}")
            if True:
                with open(input_path, "r", encoding="utf-8") as f:
                    all_file_contents = {}
                    all_file_contents[os.path.basename(input_path)] = f.read()
                result = self.generate_docs(input_path, all_file_contents)
                if result is not None:
                    docs = result
                    output_filename = os.path.splitext(os.path.basename(input_path))[0] + ".md"
                    output_path = os.path.join(docs_dir, output_filename)
                    pathlib.Path(os.path.dirname(output_path)).mkdir(parents=True, exist_ok=True)
                    with open(output_path, "w", encoding="utf-8") as outfile:
                        outfile.write(docs)
                    generated_files.append(output_path)
                else:
                    logging.error("Error generating documentation for %s", input_path)
        elif os.path.isdir(input_path):
            logging.info(f"Input is a directory: {input_path}")
            all_file_contents = {}  # Initialize OUTSIDE

            for root, _, files in os.walk(input_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    relative_file_path = os.path.relpath(file_path, input_path)

                    if self.should_ignore(file_path, ignore_patterns):
                        logging.info(f"Ignoring file (matches pattern): {file_path}")
                        continue

                    if os.path.samefile(file_path, os.path.join(mkdocs_dir, docs_dir_name)):
                        logging.info(f"Ignoring the mkdocs directory: {file_path}")
                        continue

                    if True:
                        try:
                            with open(file_path, "r", encoding="utf-8") as f:
                                all_file_contents[relative_file_path] = f.read()  # KEY CHANGE: Relative path as key
                        except Exception as e:
                            logging.error(f"Error reading file {file_path}: {e}")
                            continue

                        docs = self.generate_docs(file_path, all_file_contents)  # Full path for generate_docs
                        if docs:
                            output_dir = os.path.join(docs_dir, os.path.dirname(relative_file_path))
                            output_filename = os.path.splitext(os.path.basename(relative_file_path))[0] + ".md"
                            output_path = os.path.join(output_dir, output_filename)

                            pathlib.Path(output_dir).mkdir(parents=True, exist_ok=True)  # Create all dirs

                            with open(output_path, "w", encoding="utf-8") as outfile:
                                outfile.write(docs)
                            generated_files.append(output_path)
                        else:
                            logging.error(f"Error generating docs for {file_path}")

        else:
            logging.warning(f"Skipping invalid path: {input_path}")

        return generated_files

    def create_project_index(
        self,
    ):
        mkdocs_dir=self.mkdocs_dir
        docs_dir=self.docs_dir
        project_name=self.project_name
        project_description=self.project_description

        project_name = project_name.lower().replace("_", "-")

        # Generate AI-based description
        def generate_ai_description(prompt):
            try:
                response = self.llm_provider.generate(prompt)
                print("generated description")
                return response
            except Exception as e:
                logging.error(f"Error calling Gemini API: {e}")
                return "AI-generated content could not be loaded."

        contributing_prompt = f"""
        Generate a 'Contributing' section for a project named {project_name} in markdown. Do not give the response in backticks. 
        Include guidelines for contributing, such as setting up the development environment and submitting pull requests.
        """
        contributing_description = generate_ai_description(contributing_prompt)

        # Create the index content
        index_content = f"""# {project_name}

{project_description}

## Getting Started

This section provides a quick overview of how to get started with {project_name}.

### Installation

```bash
pip install {project_name}
```
Contributing

{contributing_description}
License

MIT License
Repository

GitHub
"""
        # Write the content to index.md
        index_path = os.path.join(mkdocs_dir, docs_dir, "index.md")
        with open(index_path, "w", encoding="utf-8") as outfile:
            outfile.write(index_content)
            print(f"index.md written to: {index_path}")
```

```python
# Example directory structure:
# my_project/
#     module1.py
#     module2.py
# mkdocs_project/
#     mkdocs.yml
#     docs/  (This will be created if it doesn't exist)

# Create dummy files
os.makedirs("my_project", exist_ok=True)
with open("my_project/module1.py", "w") as f:
    f.write("def my_function():\n    \"\"\"A simple function.\"\"\"\n    pass")
with open("my_project/module2.py", "w") as f:
    f.write("class MyClass:\n    def __init__(self):\n        pass")

os.makedirs("mkdocs_project", exist_ok=True)
with open("mkdocs_project/mkdocs.yml", "w") as f:
    f.write("site_name: My Project\n")  # Minimal mkdocs.yml

# Instantiate MeowdocCore with a mock LLM
llm = MockLLM()
core = MeowdocCore(
    input_path="./my_project",
    mkdocs_dir="./mkdocs_project",
    docs_dir="docs",
    ignore_patterns=[],
    project_name="My Project",
    project_description="This is a test project.",
    repo_url="https://github.com/example/test_project",
    llm_provider=llm,
)

# Process the project directory
generated_files = core.process_path()
print("Generated files:", generated_files)

#Create Project Index
core.create_project_index()
```
This example demonstrates how to use the `MeowdocCore` class to generate documentation for a Python project. Note the usage of `MockLLM` for testing purposes.  A real implementation would replace this with an actual LLM provider.  The example sets up a directory structure with Python files, configures `MeowdocCore`, calls `process_path` to generate the documentation, and then creates the project's main index file by calling `create_project_index`.
